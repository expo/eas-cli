name: build-and-deploy-worker
# Assumes main branch always specifies an environment (staging/production).
# If environment is empty: PR testing build (no upload, no deploy)
# If environment is set: Build (unless cached on main), upload, and deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: '"staging", "production" or empty'
        type: string
        required: true
  workflow_call:
    inputs:
      environment:
        description: '"staging", "production" or empty'
        type: string
        required: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - uses: ./.github/actions/setup-mise

      - uses: ./.github/internal-actions/setup-gcloud

      - name: Check if worker already exists
        id: check_worker_exists
        # Check if tarballs for this SHA already exist
        # If they do, we can skip building regardless of branch
        if: inputs.environment != ''
        run: |
          for platform in android ios; do
            GCP_TARBALL="worker-$platform-sha1-$GITHUB_SHA.tar.gz"

            if ! gsutil stat gs://eas-build-worker-tarballs/$GCP_TARBALL; then
              echo "worker_exists=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          done

          echo "worker_exists=true" >> "$GITHUB_OUTPUT"

      - name: Start EAS Workflow to build worker tarballs
        id: eas_workflow
        # Build if: PR testing (no env), or deploying but tarballs don't exist
        if: inputs.environment == '' || steps.check_worker_exists.outputs.worker_exists == 'false'
        working-directory: packages/worker
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_DEV_EXPO_GITHUB_ROBOT_ACCESS_TOKEN }}
        run: |
          set -euo pipefail

          # Only upload artifacts from EAS if GHA will upload them to GCS
          # This avoids unnecessary artifact uploads for PR builds
          SHOULD_UPLOAD_ARTIFACT="${{ inputs.environment != '' && steps.check_worker_exists.outputs.worker_exists == 'false' }}"

          # Run workflow and capture output (includes run ID)
          WORKFLOW_OUTPUT=$(npx -y eas-cli@latest workflow:run build-worker.yml \
            --ref ${{ github.sha }} \
            --input upload_artifact=$SHOULD_UPLOAD_ARTIFACT \
            --non-interactive \
            --no-wait \
            --json)

          WORKFLOW_RUN_ID=$(echo "$WORKFLOW_OUTPUT" | jq -r '.id')
          if [ -z "$WORKFLOW_RUN_ID" ] || [ "$WORKFLOW_RUN_ID" = "null" ]; then
            echo "Error: Could not determine workflow run ID"
            echo "Workflow output:"
            echo "$WORKFLOW_OUTPUT" | jq .
            exit 1
          fi

          echo "workflow_run_id=$WORKFLOW_RUN_ID" >> "$GITHUB_OUTPUT"

      - name: Wait for EAS workflow and capture artifacts
        id: eas_artifacts
        if: inputs.environment == '' || steps.check_worker_exists.outputs.worker_exists == 'false'
        working-directory: packages/worker
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_DEV_EXPO_GITHUB_ROBOT_ACCESS_TOKEN }}
        run: |
          set -euo pipefail

          WORKFLOW_RUN_ID="${{ steps.eas_workflow.outputs.workflow_run_id }}"
          if [ -z "$WORKFLOW_RUN_ID" ]; then
            echo "Error: Missing workflow run ID"
            exit 1
          fi

          SHOULD_UPLOAD_ARTIFACT="${{ inputs.environment != '' && steps.check_worker_exists.outputs.worker_exists == 'false' }}"

          while true; do
            VIEW_OUTPUT=$(npx -y eas-cli@latest workflow:view "$WORKFLOW_RUN_ID" \
              --non-interactive \
              --json)
            STATUS=$(echo "$VIEW_OUTPUT" | jq -r '.status')

            case "$STATUS" in
              SUCCESS)
                break
                ;;
              FAILURE)
                echo "EAS workflow failed."
                echo "$VIEW_OUTPUT" | jq .
                exit 1
                ;;
              CANCELED)
                echo "EAS workflow canceled."
                echo "$VIEW_OUTPUT" | jq .
                exit 1
                ;;
              ACTION_REQUIRED)
                echo "EAS workflow requires action."
                echo "$VIEW_OUTPUT" | jq .
                exit 1
                ;;
              NEW|IN_PROGRESS)
                sleep 7
                ;;
              *)
                echo "Unexpected workflow status: $STATUS"
                echo "$VIEW_OUTPUT" | jq .
                exit 1
                ;;
            esac
          done

          # Skip artifact extraction if we didn't request uploads
          if [ "$SHOULD_UPLOAD_ARTIFACT" == "false" ]; then
            echo "Skipping artifact download - upload was disabled for this run"
            exit 0
          fi

          # Extract artifact download URLs from workflow output
          # Artifacts are in jobs[].artifacts[] for custom jobs
          DOWNLOAD_IOS_URL=$(echo "$VIEW_OUTPUT" | jq -r '
            .jobs[]
            | .artifacts[]?
            | select(.name == "worker-ios-tarball")
            | .downloadUrl
          ' | head -1)

          DOWNLOAD_ANDROID_URL=$(echo "$VIEW_OUTPUT" | jq -r '
            .jobs[]
            | .artifacts[]?
            | select(.name == "worker-android-tarball")
            | .downloadUrl
          ' | head -1)

          if [ -z "$DOWNLOAD_IOS_URL" ] || [ "$DOWNLOAD_IOS_URL" = "null" ]; then
            echo "Error: Could not find iOS artifact download URL"
            echo "$VIEW_OUTPUT" | jq .
            exit 1
          fi

          if [ -z "$DOWNLOAD_ANDROID_URL" ] || [ "$DOWNLOAD_ANDROID_URL" = "null" ]; then
            echo "Error: Could not find Android artifact download URL"
            echo "$VIEW_OUTPUT" | jq .
            exit 1
          fi

          # Mask the download URLs
          echo "::add-mask::$DOWNLOAD_IOS_URL"
          echo "::add-mask::$DOWNLOAD_ANDROID_URL"
          echo "download_ios_url=$DOWNLOAD_IOS_URL" >> "$GITHUB_OUTPUT"
          echo "download_android_url=$DOWNLOAD_ANDROID_URL" >> "$GITHUB_OUTPUT"

      - name: Cancel EAS workflow on GitHub cancellation
        if: cancelled()
        working-directory: packages/worker
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_DEV_EXPO_GITHUB_ROBOT_ACCESS_TOKEN }}
        run: |
          set -euo pipefail

          WORKFLOW_RUN_ID="${{ steps.eas_workflow.outputs.workflow_run_id }}"
          if [ -n "$WORKFLOW_RUN_ID" ]; then
            npx -y eas-cli@latest workflow:cancel "$WORKFLOW_RUN_ID" --non-interactive
          fi

      - name: Upload worker tarballs to GCP
        # Upload when deploying if we built something new
        # Don't upload PR builds (no environment) or when using cached tarballs
        if: inputs.environment != '' && steps.check_worker_exists.outputs.worker_exists == 'false'
        run: |
          IOS_GCP_TARBALL="worker-ios-sha1-$GITHUB_SHA.tar.gz"
          ANDROID_GCP_TARBALL="worker-android-sha1-$GITHUB_SHA.tar.gz"
          curl -L "${{ steps.eas_artifacts.outputs.download_ios_url }}" | gsutil cp - gs://eas-build-worker-tarballs/$IOS_GCP_TARBALL
          curl -L "${{ steps.eas_artifacts.outputs.download_android_url }}" | gsutil cp - gs://eas-build-worker-tarballs/$ANDROID_GCP_TARBALL

      - name: Promote worker to ${{ inputs.environment }}
        if: inputs.environment != ''
        run: |
          for platform in android ios; do
            GCP_TARBALL="worker-$platform-sha1-$GITHUB_SHA.tar.gz"
            WORKER_STAGING_TARBALL="worker-$platform-${{ inputs.environment }}.tar.gz"

            gsutil cp gs://eas-build-worker-tarballs/$GCP_TARBALL gs://eas-build-worker-tarballs/$WORKER_STAGING_TARBALL
          done
